class("autoexpenser::main","widget")
{
	function zzzComments(this function only holds comments for developer reasons)
	{
		/* autoexpenser::main::zzzComments
		
			This function holds comments for the developer.
		
		======== Class Members ======== 
		
		@%arrBDTKeepColumns (array)
		
			An array of checkbox objects.
			The array index values are created at runtime when a user clicks the Load Bank Data button, 
			and so it is not a fixed size array. 
			Checkbox items can be accessed via: 
		
				@%arrBDTKeepColumns[%i]->$checkboxFunction
		
			where $checkboxFunction is any function from the checkbox class
		
			See also: @%arrBDTKeepColumnsNewNames
		
		---
		@%arrBDTKeepColumnsNewNames (array)
		
			An array of lineedit objects.
			The array index values are created at runtime when a user clicks the Load Bank Data button, 
			and so it is not a fixed size array. 
			Lineedit items can be accessed via: 
		
				@%arrBDTKeepColumnsNewNames[%i]->$lineditFunction
		
			where $lineeditFunction is any function from the lineedit class
		
			See also: @%arrBDTKeepColumns
		
		*/
	}
	
	function slotUpdateWidgets(this function can be used to update any widget)
	{
		/* autoexpenser::main::slotUpdateWidgets
		
			This function is a way to update any widget you like.
			You can decide the flow of the program depending on the signalPrint we generate when this function runs
			The signalPrint is the name of the object that emitted the signal, with the signalName attached on the end
		
		*/
		
		// check the signal sender name first
		%signalSender	= @$signalSender->$name()
		%signalName	= @$signalName()
		%signalPrint	= %signalSender::%signalName
		
		if (@%debug) {debug -c signalPrint: %signalPrint;}
		
		if (%signalPrint == "@%a{pnd}|main|tabwidget::currentChanged")
		{
			// this slot deals with when the user changes the current tab or if the program emits the currentChanged 
			// signal for the autoexpenser::main::%tabwTabs widget
			// dev-note: $0 will contain the int value of the current tab we are on
		
			%intNewTab = $0
			//if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
			// first, react to the previous tab value
			switch (@%intPrevTab)
			{
				case ("0"):
				{
					if (@%debug) {debug -c "came from the Settings tab, so save settings to disk.";}
					# save the settings hash to disk
					%cfg = $config.open(@%s{settingsFile}, rw)
					if (%cfg)
					{
						config.clearsection %cfg settings
						config.setsection %cfg settings
						foreach (%key, $keys(@%s))
						{
							config.write %cfg %key @%s{%key}
						}
						config.close %cfg
					}
					else
					{
						dialog.message -b ("Warning", "Could not open the settings file to save settings to disk.<br/>@%s{msgDebugProb}", $icon("warning"), "/okay...")
						{}
					}
					break;
				}
				default:
				{
					if (@%debug) {debug -c "we didn't come from a significant tab, so it probably doesn't matter. the tab uid we came from was: @%intPrevTab";}
					break;
				}
			}
		
			// now react to the current tab value
		
			if (%intNewTab == "1")
			{
				// we are on the CSV Set tab (1)
				// update the data set combobox entries
		
				// save the current csv set name
				%strPrevSetName = @%coboCSVSetDataSet->$current()
				%c = 0
		
				@%coboCSVSetDataSet->$clear()
				%listDataSets = $file.ls(@%s{dataSetsPath}, "fni", "dataSet-*.conf")
				for (%i = 0; %i < %listDataSets[]#; %i++)
				{
					%listSetNames[%i] = $str.lefttofirst($str.rightfromfirst(%listDataSets[%i],"dataSet-"),".conf")
				}
				foreach (%name, %listSetNames)
				{
					@%coboCSVSetDataSet->$insertItem(%name)
					if (%name == %strPrevSetName) {%intPrevSetUID = %c;}
					%c++
				}
				// only set the previous set UID  if we have one
				if (%intPrevSetUID != $null) {@%coboCSVSetDataSet->$setCurrentItem(%intPrevSetUID);}
				@%coboCSVSetDataSet->$emit("activated")
			}
		
			// update the previous tab integer
			@%intPrevTab = %intNewTab
		}
		
		if (%signalPrint == "@%a{pnd}|main|tabwidget|Page|CSVSet|ComboBox|DataSet::activated")
		{
			// this slot deals with when the user picks a data set from the combobox on the CSV Set tab
			// this slot loads the current Data Set content from disk into multilinedit widget
			// $0 contains the integer value of the item they selected in the combobox
			%strSetName = @%coboCSVSetDataSet->$current()
			%strDataSetConfig = @%s{dataSetsPath}"/dataSet-"%strSetName".conf";
			@%hashShopSearch = @%fioConfigs->$readFromConfig(%strDataSetConfig,"hash","ShopSearch",$true)
			// clear the existing data from the multilineedit
			@%mleCSVSetKeyValuePairs->$clear()
			foreach (%search, $keys(@%hashShopSearch))
			{
				@%mleCSVSetKeyValuePairs->$append(%search" => "@%hashShopSearch{%search})
			}
		}
		
		if (%signalPrint == "@%a{pnd}|main|tabwidget|Page|CSVSets|MultiLineEdit|KeyValuePairs::lostFocus")
		{
			// this slot deals with when the multilineedit widget on the CSV Set tab loses keyboard focus -> save its content to disk.
			%hashMLEContent = @%common->$fnLinesToHash(@$signalSender()->$text(),\n," => ")
			%strOutFile = $file.fixpath(@%s{dataSetsPath}"/dataSet-"@%coboCSVSetDataSet->$current()".conf")
			%overwrite = $true
			@%fioConfigs->$writeToConfig(%strOutFile,%hashMLEContent,"ShopSearch",%overwrite,"hash")
		}
		
		if ($str.match("@%a{pnd}|main|tabwidget|Page|BankData|ArrayKeepColumnsNewNames|*::textChanged",%signalPrint) == $true)
		{
			// this slot deals with when the user changes a name of a column to keep on the Bank Data tab -> update values in @%coboSearchCol combobox
			// dev-note: this slot is called via an emit() in main::slotCheckBoxKeepColumnsToggled()
			// clear the comobobox contents first
			@%coboSearchCol->$clear()
			%n = 0
		
			// loop the keepcols array
			for (%i = 0; %i < @%arrBDTKeepColumns[]#; %i++)
			{
				// check if the column is ticked for keeping
				if (@%arrBDTKeepColumns[%i]->$isChecked() == $true)
				{
					if (@%arrBDTKeepColumnsNewNames[%i]->$text() != "")
					{
						// add the value from the lineedit to the combobox
						@%coboSearchCol->$insertItem(@%arrBDTKeepColumnsNewNames[%i]->$text(),%n)
						%n++
					}
					else
					{
						// no name entered in the lineedit
					}
				}
				else
				{
					// user has not ticked this column for keeping
				}
			}
		}
	}
	
	function slotDialogFile(this function catches the signalDialogFile thrown by any object)
	{
		/* autoexpenser::main::slotDialogFile
		
			This function catches when an object sends a signalDialogFile signal.
		
		*/
		
		//if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		if ($0)
		{
			%fileName = $0
			%senderHier = $str.split("|",@$signalSender->$name())
			%senderObject = %senderHier[$(%senderHier[]# - 1)]
			switch (%senderObject)
			{
				case ("BankDataFile"):
				{
					@%leBankDataFile->$setText(%fileName)
					@%leBankDataFile->$setCursorPosition(0)
					break;
				}
				case ("localDatabase"):
				{
					@%leLocalDatabase->$setText(%fileName)
					@%leLocalDatabase->$setCursorPosition(0)
				}
				default:
				{
					if (@%debug) {debug -c "The object that sent this signal is not known. @%s{msgDebugProb}";}
				}
			}
		}
		else
		{
			debug -c "Argument 0 was null. @%s{msgDebugProb}"
		}
	}
	
	function slotCheckBoxKeepColumnsToggled(this function handles when the Keep Column checkboxes are toggled)
	{
		/* autoexpenser::main::slotCheckBoxKeepColumnsToggled
		
			this function handles when the Keep Column checkboxes are toggled
		
			Whenever a checkbox in the Data Preservation section is toggled we need to check if the Continue button should be enabled or disabled
			The main class has a member to track this: @%intBankDataKeepCount
			Which is a counter of how many columns have been enabled. If this value hits 0 we should disable the Continue button.
		*/
		
		//debug -c you toggled checkbox: @$signalSender->$name
		//debug -c this = @$classname()
		
		// check the $isChecked() value of the signalSender and adjust the @%intBankDataKeepCount value accordingly
		if (@$signalSender->$isChecked()) {@%intBankDataKeepCount++;}
		else {@%intBankDataKeepCount--;}
		
		// if @%intBankDataKeepCount == 0, disable the Continue button
		if (@%intBankDataKeepCount == 0) {@%btnBankDataContinue->$setEnabled($false);}
		else {@%btnBankDataContinue->$setEnabled($true);}
		
		// update the @%coboSearchCol combobox widget to show any ticked columns to keep from @%arrBDTKeepColumnsNewNames and @%arrBDTKeepColumns
		// dev-note: to update @%coboSearchCol we emit a textChanged signal from @%arrBDTKeepColumnsNewNames[%i] and let the slot do the update in 
		// main::slotUpdateWidgets(); I have hard coded the signal to come from index 0 because we need to use an index value, and there should 
		// always exist a 0 index if this signal is being emitted here
		
		@%arrBDTKeepColumnsNewNames[0]->$emit("textChanged")
		
		return $true
	}
	
	function slotButtonClicked(this function handles button clicks)
	{
		/* autoexpenser::main::slotButtonClicked
		
			This function handles generic button clicks in the app
		*/
		
		%senderName = @$signalSender()->$name()
		%senderHier = $str.split("|",%senderName)
		%senderObject = %senderHier[$(%senderHier[]# - 1)]
		
		switch (%senderObject)
		{
			case ("BankDataLoad"):
			{
				@%dtblBankDataTable->$clearTable()
				%fileIn = @%leBankDataFile->$text()
				// set which seperator character to use
				switch (@%coboBankDataSepType->$textAt(@%coboBankDataSepType->$currentItem()))
				{
					case ("Comma"):	{%sep = ","; break;}
					case ("Pipe"):	{%sep = "|"; break;}
					case ("Tab"):	{%sep = "\t"; break;}
					default:		{%sep = ",";}
				}
				
				@$bankDataReadFile(%fileIn, %sep, @%cbBankDataFirstLine->$isChecked(), @%dtblBankDataTable)
				break;
			}
			case ("DataSetAdd"):
			{
				%strDialogMsg = "Enter new CSV Set name..."
				// check that the data set config folder exists, create it if it doesn't exist
				if ($file.exists(@%s{DataSetsPath}) == $false) {file.mkdir @%s{DataSetsPath};}
		
				// show dialog to create a new CSV Data Set
				dialog.textinput -i=121 -b ("Create a CSV Data Set",%strDialogMsg,"default=OK","escape=Cancel",,$$)
				{
					// dialog callback
					// $1 has the name that the user input into the dialog
					// $2 points to the autoexpenser::main object
					%objMain		= $2
					%strNewName	= $1
					if ($0 == "0" && $1 != $false)
					{
						// make a config file for data set named in $1
						%newDataSetFile = "dataSet-"%strNewName".conf"
						%strAbsToNewDSFile = $file.fixpath(%objMain->%s{DataSetsPath}"/%newDataSetFile")
		
						if ($file.exists(%strAbsToNewDSFile) == $false)
						{
							// create the new data set config file
							%cfgID = $config.open(%strAbsToNewDSFile,"rw")
							config.close %cfgID
						}
						else
						{
							// data set file with this name already exists
							dialog.message -b ("Data Set already exists","Data Set named <b>%strNewName</b> already exists.<br/>Data Set names must be unique.",220,"/okay...") {}
						}
						// update the values in the data set combobox
						%objMain->%tabwTabs->$emit("currentChanged")
					}
					else
					{
						// user cancelled the input.
					}
				}
				break;
			}
			case ("DataSetRename"): 
			{
				// rename the selected dataset (dataset name is stored in @%coboCSVSetDataSet->$current())
				// present dialog to user to alter the current name
				dialog.textinput -d=@%coboCSVSetDataSet->$current() -i=221 -b ("Rename current CSV set","Alter the name of the current CSV Set...","OK","Cancel",,$$)
				{
					debug -c \n  0: $0\n  1: $1\n  2: $2;
					if ($0 == "0")
					{
						%objMain = $2
						%strNewSetName = $1
						%strNewSetFileName = "dataSet-"$1".conf"
						%strOldSetName = %objMain->%coboCSVSetDataSet->$current()
						%strOldSetFileName = "dataSet-"%strOldSetName".conf"
		
						debug -c %objMain->%coboCSVSetDataSet->$name()
						// dirty check of passed combobox's object name
						if ($str.contains(%objMain->%coboCSVSetDataSet->$name(),"main|tabwidget|Page|CSVSet|ComboBox|DataSet"))
						{
							// compare new name against old name, if it's different carry on with renaming else just quit.
							if (%strNewSetName != "" && %strNewSetName != %strOldSetName)
							{
								// rename the file and then emit a tabchanged signal to re-read the csv sets from disk
								file.rename $file.fixpath(%objMain->%s{DataSetsPath}"/"%strOldSetFileName) $file.fixpath(%objMain->%s{DataSetsPath}"/"%strNewSetFileName)
								// emit tab changed signal with tab 1 as parameter to update the combobox contents
								%objMain->%tabwTabs->$emit("currentChanged",1)
							}
							else
							{
								// handle no name OR same name
								if (%strNewSetName == "")
								{
									dialog.message -b ("Alert","CSV Sets must have a name.",318,"/okay...") {}
								}
								else
								{
									// user gave us the same name so do nothing? as it doesn't matter.
								}
							}
						}
						else
						{
							// this is not the combobox object you are looking for
							debug -c The combobox object we expected is not the correct object. We got: %objMain->%coboCSVSetDataSet->$name() in the callback. Check data. This debug message needs to be disabled manually because it's in a dialog callback.;
						}
					}
					else
					{
						// user cancelled the input.
					}
				}
				break;
			}
			case ("DataSetRemove"): 
			{
				// remove the selected dataset (dataset name is stored in @%coboCSVSetDataSet->$current())
				%strSetName = @%coboCSVSetDataSet->$current()
				// present dialog to user to confirm the removal of the currently selected combobox item
				dialog.message -b -i=41 ("Delete current CSV Set","Are you sure you want to delete the <b>%strSetName</b> Data Set?<br/><br/>This action will not be reversible.",44,"Yes","No",,$$,%strSetName)
				{
					// dialog callback
					debug -c 0: $0\n1: $1\n2: $2\n3: $3
					%objMain = $1
					%strSetName = $2
					%strSetFileName = "dataSet-"$2".conf"
					if ($0 == 0)
					{
						// deletion confirmed
						file.remove $file.fixpath(%objMain->%s{dataSetsPath}"/"%strSetFileName)
						// emit tab changed signal with tab 1 as parameter to update the combobox contents
						%objMain->%tabwTabs->$emit("currentChanged",1)
					}
					else
					{
						// user cancelled the delete action
					}
				}
				break;
			}
			case ("KeepColumnsContinue"):
			{
				// check if user has selected any columns to preserve
				if (@%intBankDataKeepCount > 0)
				{
					// @%arrBDTKeepColumns and @%arrBDTKeepColumnsNewNames hold the bool (true = keep, false = forget) and column names to keep
					%keepCols = $array()
					%j = 0
		
					// loop the array with the bools to keep
					for (%i = 0; %i < @%arrBDTKeepColumns[]#; %i++)
					{
						if (@%arrBDTKeepColumns[%i]->$isChecked())
						{
							// check if selected column has a name in its lineedit widget
							if (@%arrBDTKeepColumnsNewNames[%i]->$text() != "")
							{
								// we're keeping this column
								%keepCols[%j] = @%arrBDTKeepColumnsNewNames[%i]->$text()
								%j++
							}
							else
							{
								// the user needs to input a name for at least one column, stop show an alert dialog and stop execution here
								dialog.message -b ("Alert","All columns to be kept must have a name assigned to them.<br/><br/>Check that you have named all columns to keep before continuing.",318,"/okay...",,,@%arrBDTKeepColumnsNewNames[%i])
								{
									// dialog callback - $1 contains the culprit widget that got us into here
									$1->$setFocus()
								}
								return $false;
							}
						}
					}
		
					// build the widgets and data for the Data Translation tab
					@%dtblNewData = $new(autoexpenser::datatable, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|datatable|NewData")
					@%dtblNewData->%columnTitles = %keepCols
					@%dtblNewData->$setColumnTitles()
		
					// dev-note: @%dtblBankDataTable is the datatable widget from the Bank Data tab
		
					%searchCol = @%coboSearchCol->$current()
					%arrMatchingRows = @%dtblBankDataTable->$searchRow($keys(@%hashShopSearch),%searchCol)
		debug -c arrMatchingRows\n\n%arrmatchingRows
		
		// this is where the data that populates the Data Translation tab's datatable is built
		
					// loop %arrMatchingRows
					foreach (%intRow, %arrMatchingRows)
					{
						// loop through the cols we want to preserve, found in @%arrBDTKeepColumns
						for (%intKeepCol = 0; %intKeepCol < @%arrBDTKeepColumns[]#; %intKeepCol++)
						{
							// check if this column should be preserved
							if (@%arrBDTKeepColumns[%intKeepCol]->$isChecked() == $true)
							{
								// check if the current col is the search column
								if (@%dtblBankDataTable->%columnTitles[%intKeepCol] == %searchCol)
								{
									// replace search matches with Shop Name values
									foreach (%searchFor, $keys(@%hashShopSearch))
									{
										// find the search term that matches the cell content & replace it with the value from hashShopSearch
										if ($str.match(%searchFor, @%dtblBankDataTable->$text(%intRow,%intKeepCol)))
										{
											%arrNewRow <+ @%hashShopSearch{%searchFor}
											break;
										}
									}
								}
								else
								{
									// else just copy the data directly over from the source table
									%arrNewRow <+ @%dtblBankDataTable->$text(%intRow,%intKeepCol)
								}
							}
						}
						@%dtblNewData->$addRow(%arrNewRow)
						%arrNewRow = $null
						%arrNewRow = $array()
					}
		
					// remove the placeholder label from the Data Translation tab if it exists
					if ($objects.exists(@%lblDataTransHelp) == $true) {delete @%lblDataTransHelp;}
		
					// add dtblNewData to Data Translation tab layout
					@%lPageDataTrans->$addMultiCellWidget(@%dtblNewData,	0,0,0,0)
					
					// switch to the Data Translation tab
					@%tabwTabs->$setCurrentPage($(@%tabwTabs->$currentPageIndex() + 1))
				}
				else
				{
					// user has not selected any columns to preserve
					// this code should never happen as the Continue button is disabled until a column is selected to keep
					dialog.message -b ("Alert","No columns were selected for preservation.",318,"/okay...") {}
				}
				break;
			}
			default:
			{
				if (@%debug) {debug -c The object that was clicked is not handled in the code. @%s{msgDebugProb};}
			}
		}
	}
	
	function settingsSaveToDisk(saves the settings hash to disk)
	{
		/* autoexpenser::main::settingsSaveToDisk
			
			this function saves the settings hash to disk.
		
			$0 will contain an integer if the @$signalName is currentChanged (Tab was changed by the user)
			
			@$parent->%intPrevTab contains the tab value prior to this signal being emitted, so it must be updated at the end of this slot code.
			we will use @%intPrevTab to determine which tab we just came from so we can decide what we should do in here.
		
			TABS
			0 = Settings
			1 = Bank Data
		
		*/
		
		%intNewTab = $0
		//if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		switch (@%intPrevTab)
		{
			case ("0"):
			{
		//		if (@%debug) {debug -c "came from the Settings tab, so save settings to disk.";}
				# save the settings hash to disk
				%cfg = $config.open(@%s{settingsFile}, rw)
				if (%cfg)
				{
					config.clearsection %cfg settings
					config.setsection %cfg settings
					foreach (%key, $keys(@%s))
					{
						config.write %cfg %key @%s{%key}
					}
					config.close %cfg
				}
				else
				{
					dialog.message -b ("Warning", "Could not open the settings file to save settings to disk.<br/>@%s{msgDebugProb}", $icon("warning"), "/okay...")
					{}
				}
				break;
			}
			default:
			{
				if (@%debug) {debug -c "we didn't come from a significant tab, so it probably doesn't matter. the tab uid we came from was: @%intPrevTab";}
				break;
			}
		}
		
		@%intPrevTab = %intNewTab
	}
	
	function settingsCatchChanges(catch setting changes and reflect them into the settings hash)
	{
		/* autoexpenser::main::settingsCatchChanges
		
			this function is a slot for the widgets in the Settings tab, for when their values change.
			the purpose of this function is to catch the changed value and put it into the @%s (settings hash)
			once the user moves focus from the settings tab, all the settings will be saved to disk
		
		*/
		
		#debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()
		
		%senderName = @$signalSender()->$name()
		
		%senderHier = $str.split("|",%senderName)
		
		%settingName = %senderHier[$(%senderHier[]# - 1)]
		
		@%s{%settingName} = $0
	}
	
	internal function loadPrivateImpls(loads privateimpls for this class because sometime your are f0rced to use privateimpls to handle events)
	{
		/* autoexpenser::main::loadPrivateImpls
		
			this function loads required privateimpls
		
			Parameters - there are no parameters
		
			$0: widget:variant		The widget object to creat ehte privateimpl for
			$1: eventName:string		The event name to make the privateimpl for
			$2: signalName:string		The signal name to emit
		
			Return Value - always returns $true
		
			This function exists because I found that there are events that the object class has that can't be handled using 
			objects.connect which is a real shame, as it disjoints the code a fair bit. So this function is an attempt to try 
			to keep all the privateimpls in one place.
		
		*/
		
		privateimpl (@%mleCSVSetKeyValuePairs, focusOutEvent)
		{
			@$emit("lostFocus");
		}
		
		
		return $true
	}
	
	function constructor(runs when autoExpenser::main object is created)
	{
		/* autoExpenser::main::constructor
			
		*/
		
		### settings
		
		@%s{msgDebugDef}	= "This is a definitely a bug. You should report it to the software developer."
		@%s{msgDebugForgot}	= "If you see this, it means the developer forgot to comment this line."
		@%s{msgDebugProb}	= "This is probably a bug and should be reported to the software developer."
		@%s{osDirSlash}		= "\\"
		@%s{programName}	= "Auto Expenser"
		@%s{programNameDev}	= "autoExpenser"
		@%s{programVersion}	= "v 0.1"
		@%s{settingsFile}	= $file.fixpath($file.homedir()".autoExpenser/settings.conf")
		@%s{settingsPath}	= $file.fixpath($file.homedir()".autoExpenser")
		  @%s{dataSetsPath}	= $file.fixpath(@%s{settingsPath}"/dataSets")
		
		### variable aliases - these are aliases of some variable names above to make it easier for development
		
		@%a{pnd} 			= @%s{programNameDev}
		@%a{msgDebugDef}	= @%s{msgDebugDef}
		@%a{msgDebugForgot}	= @%s{msgDebugForgot}
		@%a{msgDebugProb}	= @%s{msgDebugProb}
		
		### class variables
		
		@%arrBDTKeepColumns			= $array()
		@%arrBDTKeepColumnsNewNames	= $array()
		@%arrCSVDataSetNames			= $array()
		@%common					= $new(autoexpenser::common, $$, "@%a{pnd}|main|common")
		@%debug 					= $true
		@%fioConfigs				= $new(autoexpenser::configio, $$, "@%a{pnd}|main|fioConfigs")
		// @%dtblNewData			= declared in main::slotButtonClicked::case ("KeepColumnsContinue")
		@%hashShopSearch			= $hash()
		@%intPrevTab				= 0
		@%intBankDataKeepCount		= 0
		
		### start up checks
		
		if ($file.exists(@%s{settingsFile}) == $false)
		{
			debug -c settingsFile does not exist
			if ($file.exists($str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})) == $false)
			{
				debug -c program user directory does not exist, attempting to create it
				debug -c we are making: $str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})
				file.mkdir $str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})
			}
		}
		
		### widgets
		
		@$setWindowTitle(@%s{programName} @%s{programVersion})
		@$setGeometry(0,0,560,300)
		@$centerToScreen()
		
		@%l0 = $new(layout, $$, "@%a{pnd} | main | layout 0")
		@%l0->$setSpacing(20)
		
		// create tabWidget
		@%tabwTabs = $new(tabWidget, $$, "@%a{pnd}|main|tabwidget")
		
		// add the tabwidget to the layout of the main window widget
		@%l0->$addMultiCellWidget(@%tabwTabs, 1,1,0,0)
		
		// create tab 'pages'
		@%wgtPageSettings	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|Settings")
		@%wgtPageCSVSet		= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|CSVSet")
		@%wgtPageBankData	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|BankData")
		@%wgtPageDataTrans	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|DataTrans")
		
		// create 'page' layout
		@%lPageSettings = $new(layout, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Layout")
		@%lPageCSVSet = $new(layout, @%wgtPageCSVSet, "@%a{pnd}|main|tabwidget|Page|CSVSet|Layout")
		@%lPageBankData = $new(layout, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Layout")
		@%lPageDataTrans = $new(layout, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|Layout")
		
		// create 'page' child widgets
		
		### Settings tab
			// Local
		@%lblSettingsTitleLocal = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|TitleLocal")
		@%lblSettingsTitleLocal->$setText("<b>Local</b>")
		
		@%lblLocalDatabase = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|localDatabase")
		@%lblLocalDatabase->$setText("Database Location: ")
		
		@%leLocalDatabase = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|localDatabase")
		@%leLocalDatabase->$setMinimumWidth(50)
		
		@%btnLocalDatabase = $new(button, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Button|localDatabase")
		@%btnLocalDatabase->$setText("Browse")
		
			// Remote
		@%lblSettingsTitleRemote = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|TitleRemote")
		@%lblSettingsTitleRemote->$setText("<b>Remote</b>")
		
		@%lblRemoteDBHost = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBHost")
		@%lblRemoteDBHost->$setText("Database Host: ")
		@%leRemoteDBHost = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBHost")
		@%leRemoteDBHost->$setMinimumWidth(50)
		
		@%lblRemoteDBUser = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBUser")
		@%lblRemoteDBUser->$setText("Database User: ")
		@%leRemoteDBUser = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBUser")
		@%leRemoteDBUser->$setMinimumWidth(50)
		
		@%lblRemoteDBPass = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBPass")
		@%lblRemoteDBPass->$setText("Database Password: ")
		@%leRemoteDBPass = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBPass")
		@%leRemoteDBPass->$setMinimumWidth(50)
		@%leRemoteDBPass->$setEchoMode(Password)
		
		@%lblRemoteDBName = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBName")
		@%lblRemoteDBName->$setText("Database Name: ")
		@%leRemoteDBName = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBName")
		@%leRemoteDBName->$setMinimumWidth(50)
		
		@%lblRemoteDBTable = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBTable")
		@%lblRemoteDBTable->$setText("Table Name: ")
		@%leRemoteDBTable = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBTable")
		@%leRemoteDBTable->$setMinimumWidth(50)
		
			// page layout settings
		
		@%lPageSettings->$addMultiCellWidget(@%lblSettingsTitleLocal,		0,0,0,2)
		@%lPageSettings->$addMultiCellWidget(@%lblLocalDatabase,			1,1,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leLocalDatabase,			1,1,1,1)
		@%lPageSettings->$addMultiCellWidget(@%btnLocalDatabase,			1,1,2,2)
		@%lPageSettings->$addMultiCellWidget(@%lblSettingsTitleRemote,		2,2,0,2)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBHost,			3,3,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBHost,			3,3,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBUser,			4,4,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBUser,			4,4,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBPass,			5,5,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBPass,			5,5,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBName,			6,6,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBName,			6,6,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBTable,			7,7,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBTable,			7,7,1,1)
		
		@%lPageSettings->$setRowStretch(0, 0)
		@%lPageSettings->$setRowStretch(1, 1)
		@%lPageSettings->$setColumnStretch(0, 1)
		@%lPageSettings->$setColumnStretch(1, 2)
		@%lPageSettings->$setColumnStretch(2, 0)
		
		@%lPageSettings->$setAlignment(@%lblSettingsTitleLocal,	Bottom)
		@%lPageSettings->$setAlignment(@%lblSettingsTitleRemote,	Bottom)
		
		### CSVSets  tab
		
		@%btnCSVSetAdd = $new(button, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Button|DataSetAdd")
		@%btnCSVSetAdd->$setText("➕")
		@%btnCSVSetAdd->$setTooltip("Add a New CSV Set")
		@%btnCSVSetAdd->$setMaximumWidth(30)
		
		@%lblCSVSetDataSet = $new(label, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Label|DataSet")
		@%lblCSVSetDataSet->$setText("CSV Set: ")
		
		@%coboCSVSetDataSet = $new(combobox, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|ComboBox|DataSet")
		
		@%btnCSVSetRemove = $new(button, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Button|DataSetRemove")
		@%btnCSVSetRemove->$setText("➖")
		@%btnCSVSetRemove->$setTooltip("Remove the selected CSV Set")
		@%btnCSVSetRemove->$setMaximumWidth(30)
		
		@%btnCSVSetRename = $new(button, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Button|DataSetRename")
		@%btnCSVSetRename->$setText("📛")
		@%btnCSVSetRename->$setTooltip("Rename the selected CSV Set")
		@%btnCSVSetRename->$setMaximumWidth(30)
		
		@%mleCSVSetKeyValuePairs = $new(multilineedit, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSets|MultiLineEdit|KeyValuePairs")
		@%mleCSVSetKeyValuePairs->$setFamily("Courier")
		@%mleCSVSetKeyValuePairs->$setFocusPolicy("StrongFocus")
		
		@%lPageCSVSet->$addMultiCellWidget(@%btnCSVSetAdd,			0,0,0,0)
		@%lPageCSVSet->$addMultiCellWidget(@%lblCSVSetDataSet,		0,0,1,1)
		@%lPageCSVSet->$addMultiCellWidget(@%coboCSVSetDataSet,		0,0,2,2)
		@%lPageCSVSet->$addMultiCellWidget(@%btnCSVSetRename,			0,0,3,3)
		@%lPageCSVSet->$addMultiCellWidget(@%btnCSVSetRemove,			0,0,4,4)
		@%lPageCSVSet->$addMultiCellWidget(@%mleCSVSetKeyValuePairs,	1,1,0,4)
		
		@%lPageCSVSet->$setColumnStretch(0, 0)
		@%lPageCSVSet->$setColumnStretch(1, 0)
		@%lPageCSVSet->$setColumnStretch(2, 1)
		@%lPageCSVSet->$setColumnStretch(3, 0)
		@%lPageCSVSet->$setColumnStretch(3, 0)
		
		### Bank data tab
		
		@%lblBankDataFile = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|BankDataFile")
		@%lblBankDataFile->$setText("Bank Data File: ")
		
		@%leBankDataFile = $new(lineedit, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Line Edit|BankDataFile")
		@%leBankDataFile->$setMinimumWidth(50)
		
		@%btnBankDataFile = $new(button, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Button|BankDataFile")
		@%btnBankDataFile->$setText("Browse")
		
		@%lblBankDataSepType = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|BankDataSepType")
		@%lblBankDataSepType->$setText("Seperator: ")
		@%coboBankDataSepType = $new(combobox, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|ComboBox|BankDataSepType")
		@%coboBankDataSepType->$insertItem("Comma")
		@%coboBankDataSepType->$insertItem("Pipe")
		@%coboBankDataSepType->$insertItem("Tab")
		
		@%cbBankDataFirstLine = $new(checkbox, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|CheckBox|BankDataFirstline")
		@%cbBankDataFirstLine->$setText("First line has column titles")
		
		@%btnBankDataLoad = $new(button, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Button|BankDataLoad")
		@%btnBankDataLoad->$setText("Load Data")
		
		@%dtblBankDataTable = $new(autoexpenser::datatable, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|datatable|BankDataTable")
		
		@%lblBankDataStatus = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|Status")
		@%lblBankDataStatus->$setFrameStyle("Sunken")
		@%lblBankDataStatus->$setText("")
		@%lblBankDataStatus->$setMouseTracking($true)
		
			// page layout settings
		
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataFile,		0,0,0,0)
		@%lPageBankData->$addMultiCellWidget(@%leBankDataFile,		0,0,1,1)
		@%lPageBankData->$addMultiCellWidget(@%btnBankDataFile,		0,0,2,2)
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataSepType,		1,1,0,0)
		@%lPageBankData->$addMultiCellWidget(@%coboBankDataSepType,	1,1,1,2)
		@%lPageBankData->$addMultiCellWidget(@%cbBankDataFirstLine,	2,2,0,2)
		@%lPageBankData->$addMultiCellWidget(@%btnBankDataLoad,		3,3,0,2)
		@%lPageBankData->$addMultiCellWidget(@%dtblBankDataTable,		4,6,0,2)
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataStatus,		7,7,0,2)
		
		@%lPageBankData->$setRowStretch(7, 0)
		@%lPageBankData->$setRowStretch(5, 1)
		
		### Data Translation tab
		
		@%lblDataTransHelp = $new(label, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|Label|Help")
		@%lblDataTransHelp->$setText("If you see this message go back to the Bank Data tab and do the following: <br/><ol><li>Select a CSV data file</li><li>Select Seperator type and Title row options</li><li>Click Load Data button</li><li>Select which columns to preserve and set title names</li><li>Click Continue button</li></ol>")
		
		
			// page layout settings
		
		@%lPageDataTrans->$addMultiCellWidget(@%lblDataTransHelp,		0,0,0,0)
		
		// add 'pages' to tabwidget
		@%tabwTabs->$addTab(@%wgtPageSettings,	"Settings")
		@%tabwTabs->$addTab(@%wgtPageCSVSet,		"CSV Sets")
		@%tabwTabs->$addTab(@%wgtPageBankData,	"Bank Data")
		@%tabwTabs->$addTab(@%wgtPageDataTrans,	"Data Translation")
		
		### objects connect
		
		objects.connect @%btnBankDataFile		clicked			$$ browseButtonClicked
		objects.connect @%btnBankDataFile		signalDialogFile	$$ slotDialogFile
		
		objects.connect @%btnBankDataLoad		clicked			$$ slotButtonClicked
		
		objects.connect @%btnCSVSetAdd			clicked			$$ slotButtonClicked
		objects.connect @%btnCSVSetRename		clicked			$$ slotButtonClicked
		objects.connect @%btnCSVSetRemove		clicked			$$ slotButtonClicked
		
		objects.connect @%btnLocalDatabase		clicked			$$ browseButtonClicked
		objects.connect @%btnLocalDatabase		signalDialogFile	$$ slotDialogFile
		
		objects.connect @%coboCSVSetDataSet		activated			$$ slotUpdateWidgets
		
		objects.connect @%mleCSVSetKeyValuePairs	lostFocus			$$ slotUpdateWidgets
		objects.connect @%leLocalDatabase		textChanged		$$ settingsCatchChanges
		
		objects.connect @%tabwTabs				currentChanged		$$ slotUpdateWidgets
		
		/* dev-note: other objects.connect calls may be made elsewhere at runtime. current list of locations: 
		
			Function									Widget
			bankDataReadFile (called from slotButtonClicked)	@%btnBankDataContinue
			bankDataReadFile							@%arrBDTKeepColumns[%i]
		*/
		
		### main run
		@$show()
		
		### f0rced privateimpls
		
		@$loadPrivateImpls()
	}
	
	function browseButtonClicked(handles a browse button that is used to look for a file)
	{
		/* autoexpenser::main::browseButtonClicked
		
			This function is a slot to handle when a "Browse" button is clicked when the user wants to search for a file.
		*/
		
		#if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		dialog.file -b ("Open", "Open File...",,, @$signalSender, @%s{msgDebugForgot}, @%s{msgDebugDef})
		{
			// dev-note:	$0 contains the absolute path to the chosen file. if the user cancels, $0 will be null
			//			$1 will contain the signalSender name, so we can determine what we should do with $0 if it exists
			//			$2 contains a debug message string
			//			$3 contains a debug message string
			if ($0)
			{
				if ($1)
				{
					%signalSender = $1
					%signalSender->$emit("signalDialogFile", $0)
				}
				else
				{
					debug -c "Argument 1 (signalSender) was null. This is a problem because we don't know which widget asked for the file. $3"
				}
			}
			else
			{
				debug -c "Argument 0 (filename) was null. User must have cancelled the selection. $2"
			}
		
		}
	}
	
	function bankDataReadFile(this function parses a file into the bankdatatable object)
	{
		/* autoexpenser::main::bankDataReadFile
		
			This function parses a file into the bankdatatable object: @%dtblBankDataTable
			If the function successfully imports data from the file, it will build a set of child widgets
			for the user to select which data to bring over to the Data Translation tab.
		
			The child widgets will be accessed in the autoexpenser::main::slotButtonClicked function, 
			case ("KeepColumnsContinue")
		
			Parameters - bankDataReadFile(<filename>,<seperator>,[firstRow],[target])
		
				$0: filename:string		The filename to read from
				$1: seperator:string		The seperator character to use on the file data
				$2: firstRow:bool		Whether the first line in the file has column titles or not
				$3: target:datatable		The datatable objects to put the parsed data into
		*/
		
		%fileIn = $0
		%firstRow = $2
		%sep = $1
		%success = $false
		%target = $3
		
		if (%fileIn && %sep)
		{
			if ($file.exists(%fileIn))
			{
				%emptyLines = 0
				%fileH = $new(file,,"slotButtonClicked|File Handling Object")
				%fileH->$setName(%fileIn)
				%fileH->$open("ReadOnly")
				%i = 0
				%line = $true
				%rowsAdded = 0
				%target->%columnTitles = $array()
		
				while (%line)
				{
					%line = %fileH->$readLine()
					
					%row = $str.split(%sep,%line)
					if (%i == 0)
					{
						%countCol = %row[]#;
						%target->$setColumnCount(%countCol)
						# set placeholder column titles
						for (%j = 0; %j < %countCol; %j++)
						{
							%target->%columnTitles <+ $str.upcase($char($(%j + 97)))
						}
		
						if (%firstRow)
						{
							// use this row to set the column titles
							// check if row field value has quotes on both ends, remove if it does.
							for (%j = 0; %j < %row[]#; %j++)
							{
								if ($str.match(\"*\",%row[%j]))
								{
									%row[%j] = $str.rightfromfirst($str.chop($str.strip(%row[%j]), 1),\")
								}
							}
							%target->%columnTitles = %row
						}
						%target->$setColumnTitles()
					}
		
					// process line as a normal row
					// check if this row has enough columns
					if (%row[]# >= %countCol)
					{
						// sort this row into 'acceptable' row data: add directly to bankdatatable object
						%target->$addRow(%row)
						%rowsAdded++
					}
					else
					{
						// sort this row into 'problematic' row data
						// check if the line is not empty
						if (%line != "")
						{
							// add this line's content to the problematic data tablewidget
						}
						else
						{
							// this line is empty, dont worry about it
							%emptyLines++
						}
					}
					%i++
					@%lblBankDataStatus->$setText("%i total lines read from file. %rowsAdded rows added to data table. %emptyLines empty lines in file.")
					@%lblBankDataStatus->$setFrameStyle("Box", "Raised")
				}
				%success = $true
			}
			else
			{
				dialog.message -b ("Notice", "Bank data file not found.<br/><br/>There was no file found at:<br/><br/>%fileIn<br/><br/>Check the filename and path and try again.", $icon(info), "/okay...")
				{}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%s{msgDebugProb}";}
		}
		
		// create options at bottom of the Bank Data page for Data Translation
		if (%success)
		{
			# if the widgets for the column preservation already exist, we should delete/reset them first.
			if ($isSet(@%vboxKeepColumns)) {delete @%vboxKeepColumns;}
			if ($isSet(@%arrBDTKeepColumns)) {@%arrBDTKeepColumns = $array();}
			if ($isSet(@%arrBDTKeepColumnsNewNames)) {@%arrBDTKeepColumnsNewNames = $array();}
		
		//	debug -c isSet vbox: $isSet(@%vboxKeepColumns)
		
			@%vboxKeepColumns 		= $new(vbox, @%wgtPageBankData)
		
			@%lblBankDataKeepColumns	= $new(label, @%vboxKeepColumns)
			@%lblBankDataKeepColumns->$setText("<b>Column Preservation</b>")
			@%lblBankDataKeepColumns->$setToolTip("Select which columns to preserve and what to call them")
		
			@%hboxKeepColumns 		= $new(hbox, @%vboxKeepColumns)
			@%hboxKeepColumnsNewNames	= $new(hbox, @%vboxKeepColumns)
		
			@%lblSearchCol = $new(label, @%vboxKeepColumns)
			@%lblSearchCol->$setText("Search this column for CSV Set matches: ")
		
			@%coboSearchCol = $new(combobox, @%vboxKeepColumns, "@%a{pnd}|main|tabwidget|Page|BankData|combobox|SearchCol")
			
			@%btnBankDataContinue		= $new(button, @%vboxKeepColumns, "@%a{pnd}|main|tabwidget|Page|BankData|Button|KeepColumnsContinue")
			@%btnBankDataContinue->$setText("Continue")
			@%btnBankDataContinue->$setEnabled($false)
			objects.connect @%btnBankDataContinue clicked $$ slotButtonClicked
		
		//	debug -c columnTitles: @%dtblBankDataTable->%columnTitles
		
			for (%i = 0; %i < @%dtblBankDataTable->%columnTitles[]#; %i++)
			{
				%colTitle = @%dtblBankDataTable->%columnTitles[%i]
				// for each columnTitle, we need to make a checkbox
				@%arrBDTKeepColumns[%i] = $new(checkbox, @%hboxKeepColumns, "@%a{pnd}|main|tabwidget|Page|BankData|ArrayKeepColumns|%i")
				@%arrBDTKeepColumns[%i]->$setText(%colTitle)
				@%arrBDTKeepColumns[%i]->$setToolTip("Tick to preserve %colTitle column for Data Translation")
		
				@%arrBDTKeepColumnsNewNames[%i] = $new(lineedit, @%hboxKeepColumnsNewNames, "@%a{pnd}|main|tabwidget|Page|BankData|ArrayKeepColumnsNewNames|%i")
				@%arrBDTKeepColumnsNewNames[%i]->$setText("%colTitle")
				@%arrBDTKeepColumnsNewNames[%i]->$setToolTip("Enter the name that you want the %colTitle column to be after Data Translation")
		
				objects.connect @%arrBDTKeepColumns[%i] 		toggled		$$ slotCheckBoxKeepColumnsToggled
				objects.connect @%arrBDTKeepColumnsNewNames[%i] textChanged	$$ slotUpdateWidgets
			}
		
			@%lPageBankData->$addMultiCellWidget(@%vboxKeepColumns, 9,9,0,2)
		}
		
		return %success
	}
	
}

class("autoexpenser::datatable","tablewidget")
{
	function setColumnTitles(sets the column titles using the classes internal column title array)
	{
		/* autoexpenser::datatable::setColumnTitles
		
			set the column titles for the tablewidget based on the @%columnTitles array
			dev-note: note that @%columnTitles is part of the datatable class, not the main class.
		
		*/
		
		@$setColumnCount(@%columnTitles[]#)
		@$setHorizontalHeaderLabels(@%columnTitles)
		return $true
	}
	
	function searchRow(searches a row for a string)
	{
		/* autoexpenser::datatable::searchRow
			
			this function searches a row in the datatable for a string (wildcard supported)
		
			Parameters - searchRow(<find>,[columnsToSearch])
		
				$0: arrFind:csvList/array			Strings to search for. Wildcard characters supported as per $str functions
				$1: columnsToSearch:csvList/array	Column names to look at during the search (optional)
		
			$0 arrFind can be either a comma seperated string or an array
			$1 columnsToSearch can be either a comma seperated string or an array
			If $1 columnsToSearch is not supplied, all columns in the row will be searched
		
			Return Value
				
				This function will return an array that holds the uid integer value of every row that matched the search.
				If no matches were found in all the rows, this function will return $false.
		
		*/
		
		%intRows			= @$rowCount()
		%intCols			= @$columnCount()
		
		%columnsToSearch	= $str.split(",",$1)
		%arrFind 			= $str.split(",",$0)
		
		debug -c arrFind = %arrFind
		
		%success			= $array()
		%successCount		= 0
		
		// loop through rows in datatable
		for (%i = 0; %i < %intRows; %i++)
		{
			// loop through columns in current row
			for (%n = 0; %n < %intCols; %n++)
			{
				// check if we want to search the current column
				if (%columnsToSearch == $false || $str.grep(@%columnTitles[%n],%columnsToSearch,"w"))
				{
					// check if any of the search terms are in the current cell's text
					foreach (%s, %arrFind)
					{
						if ($str.match(%s,@$text(%i,%n)) == $true)
						{
							%success <+ %i
							break;
						}
					}
				}
				// check if we found a match in the current column so we can break out of the column traversing loop
				if (%successCount < %success[]#)
				{
					// increment the successCounter first before breaking
					%successCount++
					break;
				}
			}
		}
		
		if (%successCount == 0) {%success = $false;}
		return %success
	}
	
	function getColumnTitles(return the column titles as a list object)
	{
		// autoexpenser::datatable::getColumnTitles
		// return the column titles as a list object
		
		%success = $false
		%colCount = @$columnCount()
		
		if (%colCount > 0)
		{
			for (%i = 0; %i < %colCount; %i++)
			{
				
			}
		}
		
		return %success
	}
	
	function constructor(runs when the datatable object is created)
	{
		/* autoexpenser::datatable::constructor
		
		*/
		
		### class members
		
		// inherit debug value from the parent if it exists, else set debug to false
		if (@$parent == $true) {@%debug = @$parent()->%debug;} else {@%debug = $false;}
		
		@%s{msgDebugDef}	= "This is a definitely a bug. You should report it to the software developer."
		@%s{msgDebugForgot}	= "If you see this, it means the developer forgot to comment this line."
		@%s{msgDebugProb}	= "This is probably a bug and should be reported to the software developer."
		
		@%columnKeepTitles = $hash()
		@%columnTitles = $array()
		@%intRowCurrent = 0
	}
	
	function clearTable(clears the current table back to zero contents)
	{
		/* autoexpenser::datatable::clearTable
		
			clears the current table back to zero contents
		*/
		
		@$clear()
		for ($false; @%intRowCurrent >= 0; @%intRowCurrent--)
		{
			@$removeRow(@%intRowCurrent)
		}
		@%intRowCurrent = 0
		return $true
	}
	
	function addRow(adds a row to the datatable object)
	{
		/* autoexpenser::datatable::addRow
		
			Adds a row to the datatable object
		
			Parameters - addRow(<rowData>)
		
				$0:  addRow:array		Array that holds the data to insert into the row
		
		*/
		
		%rowData			= $0
		%strAcceptedFlags	= "selectable,editable,dragEnabled,dropEnabled,userCheckable,enabled,tristate"
		%success 			= $false
		
		if ($typeOf(%rowData) == "array")
		{
			@$setRowCount($(@$rowCount + 1))
			for (%i = 0; %i < %rowData[]#; %i++)
			{
				// check if row field value has quotes on both ends, remove if it does.
				if ($str.match(\"*\",%rowData[%i]))
				{
					%rowData[%i] = $str.rightfromfirst($str.chop($str.strip(%rowData[%i]), 1),\")
				}
				// note: %i is the column uid, @%intRowCurrent is the row uid
				@$setText(@%intRowCurrent,%i,%rowData[%i])
			}
			@%intRowCurrent++
			%success = $true
		}
		else
		{
			if (@%debug) {debug -c "Argument 0 (rowData) was not type 'array'. Check your data values. @%s{msgDebugForgot}";}
		}
		
		return %success
	}
	
}

class("autoexpenser::configio","object")
{
	function writeToConfig(writes values to KVIrc Config type file)
	{
		/* autoexpenser::fileio::writeToConfig
			
			this function writes values to a KVIrc config type file
		
			Parameters - writeToConfig(<targetFilename>,<values>,[configSection],[containerType],[sort])
		
				$0: targetFilename:string	The filename to write to
				$1: values:variant		The variable that will hold the values to write to file
				$2: configSection:string	The section in the config file to write to
				$3: overwrite:boolean		The section values will be overwritten instead of appended
				$4: containerType:string	The type of the values variant (optional)
				$5: sort:boolean		Switch to sort values before they are written to file
		
			If $2 configSection is specified, the function will write to that section of the config file.
			If $3 overwrite is $true, the function will clear the section's current values and only write the values passed to the 
			section. The default is to append or add the values to the section, or update existing values.
			If $4 containerType is not specified, the function will attempt to detect what type of container the values are in
			and act accordingly.
			If $5 is $true the function will sort the values before they write to disk if possible.
		
			Return Value
				
				This function will return boolean $false if the values argument type passed to it is not recognized.
				If the values argument type is recognized, either string "zero" will be returned (if the values argument was empty)
				or the integer number of values written to the config will be returned.
		
		*/
		
		%configSection	= $2
		%containerType	= $4
		%overwrite		= $3
		%sort 		= $5
		%success		= $false
		%targetFilename	= $0
		%values		= $1
		
		if (%targetFilename == $true && %values == $true) 
		{
			if (%containerType == $false)
			{
				//if (@%debug) {debug -c "containerType was not found. @%a{msgDebugForgot}";}
				# no container type passed to us, so we have to try to detect what type of conatiner our values are in
				%containerType = $typeof(%values)
				if (%containerType == "hobject")
				{
					%containerType = %values->$className()
				}
			}
			
			%cfgID = $config.open(%targetFilename,"rw")
			if (%cfgID == $true)
			{
				if (%overwrite == $true) {config.clearsection %cfgID %configSection;}
				if (%configSection == $true) {config.setsection %cfgID %configSection;}
				// dev-note: we can now do a switch/case on %containerType to process the values to save to config
				// if the containerType is unknown in our switch/case block, we wont save anything to file and output debug error instead
				switch (%containerType)
				{
					case ("array"):
					{
						%success = 0
						// loop array
						for (%i = 0; %i <= %values[]#; %i++)
						{
							config.write %cfgID %i %values[%i]
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					case ("hash"):
					{
						%success = 0
						// loop hash
						foreach (%k, $keys(%values))
						{
							config.write %cfgID %k %values{%k}
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					case ("list"):
					{
						%success = 0
						// iterate list
						%values->$moveFirst()
						while (%values->$moveNext())
						{
							config.write %cfgID %success %values->$current()
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					default:
					{
						// handle unknown containerType
						if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type. Check the variables passed to this function. @%a{msgDebugProb}";}
						break;
					}
				} // end switch
				config.close %cfgID
			}
			else
			{
				if (@%debug) {debug -c "Argument 0: '%targetFilename' failed to open. Check file permissions?. @%a{msgDebugProb}";}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%a{msgDebugDef}";}
		}
		
		return %success
	}
	
	function readFromConfig(reads values from KVIrc Config type file)
	{
		/* autoexpenser::fileio::readFromConfig
			
			this function reads values from a KVIrc config type file
		
			Parameters - readFromConfig(<sourceFilename>,<containerType>,[configSection],[sort])
		
				$0: sourceFilename:string	The filename to read from
				$1: containerType:string	The type of the values variant (optional)
				$2: configSection:string	The section in the config file to read from. If this is not set, the entire config will 
									be read.
				$3: sort:boolean		Switch to sort values after they are read from file
		
			If $1 configSection is specified, the function will read from that section of the config file, else it will read the entire
			config.
			$2 containerType is not specified, the function will attempt to detect what type of container the values will be in
			and act accordingly
			If $3 is $true the function will sort the values after they are read from disk if possible.
		
			Return Value
				
				This function will return an object of %containerType with values from %sourceFilename. 
				If %configSection is specified, it will only return values from that section in the %sourceFilename.
				If %sort is $true, it will sort the values in the returned object if possible.
				Otherwise it will return $false.
				Note: to find out how many items were pulled from the config file, you should count the returned object entries 
				in the calling code.
		
		*/
		
		%configSection	= $2
		%containerType	= $1
		%sort 		= $3
		%success		= $null
		%sourceFilename	= $0
		
		if (%sourceFilename == $true && %containerType == $true) 
		{
			// ensure config file exists
			if ($file.exists(%sourceFilename))
			{
				if (%containerType == "list") {%success = $new(list);	}
		
				%cfgID = $config.open(%sourceFilename,"r")
				if (%cfgID == $true)
				{
					%sections = $config.sectionlist(%cfgID)
					// loop through entire config, section-by-section. check if user wants a specific section else get all the values
					foreach --all (%currentSection, %sections)
					{
						if ((%configSection == $false) || (%configSection == $true && %currentSection == %configSection))
						{
							config.setsection %cfgID %currentSection
							%sectionKeys = $config.keylist(%cfgID)
							if (%sectionKeys == $true)
							{
								foreach (%k, %sectionKeys)
								{
									%v = $config.read(%cfgID, %k)
									// dev-note: we can now do a switch/case on %containerType to process the values to read from config
									// if the containerType is unknown in our switch/case block, we wont read anything from file and output debug error instead
									switch (%containerType)
									{
										case ("array"):
										{
											%success[%k] = %v
											break;
										}
										case ("hash"):
										{	
											%success{%k} = %v
											break;
										}
										case ("list"):
										{
											%success->$append(%v)
											break;
										}
										default:
										{
											// handle unknown containerType
											if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type. Check the variables passed to this function. @%a{msgDebugProb}";}
											break;
										}
									} // end switch
								} // end foreach
							}
							else
							{
								// no keys were found in this section, so no point entering the inner loops
								if (@%debug) {debug -c No keys were found in section: %currentSection;}
							}
						}
						else
						{
							// if we get here it means that we want a specific section from the config file, but we are 
							// processing a section that we don't want. nothing really needs to happen here.
						}
					}
					config.close %cfgID
					if (%sort == $true)
					{
						switch(%containerType)
						{
							case ("array"):
							{
								%success = $sort(%success)
								break;
							}
							case ("list"):
							{
								%success->$sort()
							}
							default:
							{
								// handle unknown containerType for sorting
								// note: hashes are not sortable afaik
								//if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type for sorting purposes. Check the variables passed to this function. @%a{msgDebugProb}";}
								break;
							}
						} // end switch
					} //end if sort == true
				}
				else
				{
					if (@%debug) {debug -c "Argument 0 sourceFilename: $b()%sourceFilename$b() could not be opened. Check folder permissions? @%a{msgDebugProb}";}
				}
			}
			else
			{
				if (@%debug) {debug -c "Argument 0 sourceFilename: $b()%sourceFilename$b() does not exist. Check folder permissions? @%a{msgDebugProb}";}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%a{msgDebugDef}";}
		}
		
		return %success
	}
	
	function constructor(the constructor of the configio class)
	{
		/* autoexpenser::fileio::constructor
		
			Notes: 
			  @%a		is an 'alias' variable, which gives access to values from the parent object.
			  @%debug 	is a boolean that enables debugging messages.
		
		*/
		
		### class members
		
		// inherit values from the parent if it exists, else use default values
		if (@$parent == $true) 
		{
			@%debug	= @$parent()->%debug;
			@%a		= @$parent()->%a;
		}
		else 
		{
			@%debug	= $false;
			@%a		= $false;
		}
	}
	
}

class("autoexpenser::common","object")
{
	function fnLinesToHash(takes a string and splits it into lines on a delimitor, then splits each line on a seperator and puts the key => value pairs into a hash for return)
	{
		/* autoexpenser::common::fnLinesToHash
		
			this function takes a string and splits it into lines on a delimitor, then splits each line on a seperator and 
			puts the key => value pairs into a hash for return
		
			Parameters - fnLinesToHash(<strInput>,<lineChar>,<seperator>)
		
				$0: strInput:string	The string to analyze
				$1: lineChar:string		The character or string to delimit a 'line' on. Usually this will be \n or \n\r.
				$2: seperator:string		The character or string to split a line into key => value pairs. Usually this will be " => ",
									"|||" or ","
			All parameters are mandatory.
		
			Return Value
				
				This function will return a hash containing the key => value pairs found in strInput after processing with 
				the given criteria. It will return false if the function fails.
		
		*/
		
		%lineChar	= $1
		%seperator	= $2
		%strInput	= $0
		%success	= $false
		
		if (%lineChar != "" && %seperator != "" && %strInput != "")
		{
			%success = $hash()
			%arrLines = $str.split(%lineChar,%strInput,"n")
			for (%i = 0; %i < %arrLines[]#; %i++)
			{
				%arrPairs = $str.split(%seperator,%arrLines[%i],"n",2)
				%success{%arrPairs[0]} = %arrPairs[1]
			}
		}
		else
		{
			// at least one of the arguments were not provided
			if (@%debug) {debug -c "Required arguments 0, 1 or 2 did not exist. Check the values passed to this function. @%a{msgDebugDef}";}
		}
		
		return %success
	}
	
	function constructor()
	{
		/* autoexpenser::common::constructor
		
			Notes: 
			  @%a		is an 'alias' variable, which gives access to values from the parent object.
			  @%debug 	is a boolean that enables debugging messages.
		
		*/
		
		### class members
		
		// inherit values from the parent if it exists, else use default values
		if (@$parent == $true) 
		{
			@%debug	= @$parent()->%debug;
			@%a		= @$parent()->%a;
		}
		else 
		{
			@%debug	= $false;
			@%a		= $false;
		}
	}
	
}

