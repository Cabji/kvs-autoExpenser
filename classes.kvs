class("autoexpenser::main","widget")
{
	function zzzComments(this function only holds comments for developer reasons)
	{
		/* autoexpenser::main::zzzComments
		
			This function holds comments for the developer.
		
		======== Class Members ======== 
		
		@%arrBDTKeepColumns (array)
		
			An array of checkbox objects.
			The array index values are created at runtime when a user clicks the Load Bank Data button, 
			and so it is not a fixed size array. 
			Checkbox items can be accessed via: 
		
				@%arrBDTKeepColumns[%i]->$checkboxFunction
		
			where $checkboxFunction is any function from the checkbox class
		
			See also: @%arrBDTKeepColumnsNewNames
		
		---
		@%arrBDTKeepColumnsNewNames (array)
		
			An array of lineedit objects.
			The array index values are created at runtime when a user clicks the Load Bank Data button, 
			and so it is not a fixed size array. 
			Lineedit items can be accessed via: 
		
				@%arrBDTKeepColumnsNewNames[%i]->$lineditFunction
		
			where $lineeditFunction is any function from the lineedit class
		
			See also: @%arrBDTKeepColumns
		
		*/
	}
	
	function slotUpdateWidgets(this function can be used to update any widget)
	{
		/* autoexpenser::main::slotUpdateWidgets
		
			This function is a way to update any widget you like.
			You can decide the flow of the program depending on the signalPrint we generate when this function runs
			The signalPrint is the name of the object that emitted the signal, with the signalName attached on the end
		
		*/
		
		// check the signal sender name first
		%signalSender	= @$signalSender()->$name()
		%signalName	= @$signalName()
		%signalPrint	= %signalSender::%signalName
		
		if (@%debug) {debug -c signalPrint: %signalPrint;}
		
		if (%signalPrint == "@%a{pnd}|main|tabwidget::currentChanged")
		{
			// the user just changed the current tab in hte program
			// dev-note: $0 will contain the int value of the current tab we are on
			if ($0 == "1")
			{
				// we are on the Data Set tab (1)
				// we should update the values in the combobox 
				@%coboCSVSetDataSet->$clear()
				%listDataSets = $file.ls(@%s{dataSetsPath}, "fni", "dataSet-*.conf")
				for (%i = 0; %i < %listDataSets[]#; %i++)
				{
					%listSetNames[%i] = $str.lefttofirst($str.rightfromfirst(%listDataSets[%i],"dataSet-"),".conf")
				}
				foreach (%name, %listSetNames)
				{
					@%coboCSVSetDataSet->$insertItem(%name)
				}
			}
		}
		
		if (%signalPrint == "@%a{pnd}|main|tabwidget|Page|CSVSet|ComboBox|DataSet::activated")
		{
			// the user just picked a data set from the combobox on the data set tab
			// $0 contains the integer value of the item they selected in the combobox
			%strSetName = @%coboCSVSetDataSet->$current()
			%strDataSetConfig = @%s{dataSetsPath}"/dataSet-"%strSetName".conf";
			%hashShopSearch = @%fioConfigs->$readFromConfig(%strDataSetConfig,"hash",ShopSearch,$true)
			@%dtblCSVSetCategories->$clearTable()
			@%dtblCSVSetCategories->%columnTitles = $array("Search For", "Shop Name")
			@%dtblCSVSetCategories->$setColumnTitles()
			foreach (%search, $keys(%hashShopSearch))
			{
				// this fandangled line below sends our hash values into a datatable object as an array so we can use the addRow() function
				@%dtblCSVSetCategories->$addRow($array(%search,%hashShopSearch{%search}),"editable")
			}
		}
	}
	
	function slotDialogFile(this function catches the signalDialogFile thrown by any object)
	{
		/* autoexpenser::main::slotDialogFile
		
			This function catches when an object sends a signalDialogFile signal.
		
		*/
		
		if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		if ($0)
		{
			%fileName = $0
			%senderHier = $str.split("|",@$signalSender->$name())
			%senderObject = %senderHier[$(%senderHier[]# - 1)]
			switch (%senderObject)
			{
				case ("BankDataFile"):
				{
					@%leBankDataFile->$setText(%fileName)
					@%leBankDataFile->$setCursorPosition(0)
					break;
				}
				case ("localDatabase"):
				{
					@%leLocalDatabase->$setText(%fileName)
					@%leLocalDatabase->$setCursorPosition(0)
				}
				default:
				{
					if (@%debug) {debug -c "The object that sent this signal is not known. @%s{msgDebugProb}";}
				}
			}
		}
		else
		{
			debug -c "Argument 0 was null. @%s{msgDebugProb}"
		}
	}
	
	function slotCheckBoxKeepColumnsToggled(this function handles when the Keep Column checkboxes are toggled)
	{
		/* autoexpenser::main::slotCheckBoxKeepColumnsToggled
		
			this function handles when the Keep Column checkboxes are toggled
		
			Whenever a checkbox in the Data Preservation section is toggled we need to check if the Continue button should be enabled or disabled
			The main class has a member to track this: @%intBankDataKeepCount
			Which is a counter of how many columns have been enabled. If this value hits 0 we should disable the Continue button.
		*/
		
		debug -c you toggled checkbox: @$signalSender->$name
		
		// check the $isChecked() value of the signalSender and adjust the @%intBankDataKeepCount value accordingly
		if (@$signalSender->$isChecked()) {@%intBankDataKeepCount++;}
		else {@%intBankDataKeepCount--;}
		
		// if @%intBankDataKeepCount == 0, disable the Continue button
		if (@%intBankDataKeepCount == 0) {@%btnBankDataContinue->$setEnabled($false);}
		else {@%btnBankDataContinue->$setEnabled($true);}
		
		debug -c KeepCount = @%intBankDataKeepCount
		return $true
	}
	
	function slotButtonClicked(this function handles button clicks)
	{
		/* autoexpenser::main::slotButtonClicked
		
			This function handles generic button clicks in the app
		*/
		
		%senderName = @$signalSender()->$name()
		%senderHier = $str.split("|",%senderName)
		%senderObject = %senderHier[$(%senderHier[]# - 1)]
		
		switch (%senderObject)
		{
			case ("BankDataLoad"):
			{
				@%dtblBankDataTable->$clearTable()
				%fileIn = @%leBankDataFile->$text()
				switch (@%coboBankDataSepType->$textAt(@%coboBankDataSepType->$currentItem()))
				{
					case ("Comma"):	{%sep = ","; break;}
					case ("Pipe"):	{%sep = "|"; break;}
					case ("Tab"):	{%sep = "\t"; break;}
					default:		{%sep = ",";}
				}
				
				@$bankDataReadFile(%fileIn, %sep, @%cbBankDataFirstLine->$isChecked(), @%dtblBankDataTable)
				break;
			}
			case ("DataSetAdd"):
			{
				%strDialogMessage = ""
				// check that the data set config folder exists, create it if it doesn't exist
				if ($file.exists(@%s{DataSetsPath}) == $false) {file.mkdir @%s{DataSetsPath};}
		
				// show dialog to create a new CSV Data Set
				dialog.textinput -i=121 -b ("Create a CSV Data Set",%strDialogMsg,"default=OK","escape=Cancel",,@%s{DataSetsPath})
				{
					// dialog callback
					if ($0 == "0" && $1 != $false)
					{
						// make a config file for data set named in $1
						%newDataSetFile = "dataSet-"$1".conf"
						%strAbsToNewDSFile = $file.fixpath($2"/%newDataSetFile")
		
						if ($file.exists(%strAbsToNewDSFile) == $false)
						{
							// create the new data set config file
							%cfgID = $config.open(%strAbsToNewDSFile,"rw")
							config.close %cfgID
						}
						else
						{
							// data set file with this name already exists
							dialog.message -b ("Data Set already exists","Data Set named <b>$1</b> already exists.<br/>Data Set names must be unique.",220,"/okay...") {}
						}
					}
					else
					{
						// user cancelled the input.
					}
				}
				break;
			}
			case ("KeepColumnsContinue"):
			{
				// check if user has selected any columns to preserve
				if (@%intBankDataKeepCount > 0)
				{
					// @%arrBDTKeepColumns and @%arrBDTKeepColumnsNewNames hold the bool (true = keep, false = forget) and column names to keep
					// build the widgets and data for the Data Translation tab
					@%dtblNewData = $new(autoexpenser::bankdatatable, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|bankdatatable|NewData")		
					%keepCols = $array()
					%j = 0
		
					// loop the array with the bools to keep
					for (%i = 0; %i < @%arrBDTKeepColumns[]#; %i++)
					{
						if (@%arrBDTKeepColumns[%i]->$isChecked())
						{
							// we're keeping this column
							%keepCols[%j] = @%arrBDTKeepColumnsNewNames[%i]->$text()
							%j++
						}
					}
					@%dtblNewData->%columnTitles = %keepCols
					@%dtblNewData->$setColumnTitles()
		
					// remove the placeholder label from the Data Translation tab
					delete @%lblDataTransHelp
					// add bdtNewData to Data Translation tab layout
					@%lPageDataTrans->$addMultiCellWidget(@%dtblNewData,	0,0,0,0)
					
					// switch to the Data Translation tab
					@%tabwTabs->$setCurrentPage($(@%tabwTabs->$currentPageIndex() + 1))
				}
				else
				{
					// user has not selected any columns to preserve
				}
				break;
			}
			default:
			{
				if (@%debug) {debug -c The object that was clicked is not handled in the code. @%s{msgDebugProb};}
			}
		}
	}
	
	function settingsSaveToDisk(saves the settings hash to disk)
	{
		/* autoexpenser::main::settingsSaveToDisk
			
			this function saves the settings hash to disk.
		
			$0 will contain an integer if the @$signalName is currentChanged (Tab was changed by the user)
			
			@$parent->%intPrevTab contains the tab value prior to this signal being emitted, so it must be updated at the end of this slot code.
			we will use @%intPrevTab to determine which tab we just came from so we can decide what we should do in here.
		
			TABS
			0 = Settings
			1 = Bank Data
		
		*/
		
		%intNewTab = $0
		if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		switch (@%intPrevTab)
		{
			case ("0"):
			{
				if (@%debug) {debug -c "came from the Settings tab, so save settings to disk.";}
				# save the settings hash to disk
				%cfg = $config.open(@%s{settingsFile}, rw)
				if (%cfg)
				{
					config.clearsection %cfg settings
					config.setsection %cfg settings
					foreach (%key, $keys(@%s))
					{
						config.write %cfg %key @%s{%key}
					}
					config.close %cfg
				}
				else
				{
					dialog.message -b ("Warning", "Could not open the settings file to save settings to disk.<br/>@%s{msgDebugProb}", $icon("warning"), "/okay...")
					{}
				}
				break;
			}
			default:
			{
				if (@%debug) {debug -c "we didn't come from a significant tab, so it probably doesn't matter. the tab uid we came from was: @%intPrevTab";}
				break;
			}
		}
		
		@%intPrevTab = %intNewTab
	}
	
	function settingsCatchChanges(catch setting changes and reflect them into the settings hash)
	{
		/* autoexpenser::main::settingsCatchChanges
		
			this function is a slot for the widgets in the Settings tab, for when their values change.
			the purpose of this function is to catch the changed value and put it into the @%s (settings hash)
			once the user moves focus from the settings tab, all the settings will be saved to disk
		
		*/
		
		#debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()
		
		%senderName = @$signalSender()->$name()
		
		%senderHier = $str.split("|",%senderName)
		
		%settingName = %senderHier[$(%senderHier[]# - 1)]
		
		@%s{%settingName} = $0
	}
	
	function constructor(runs when autoExpenser::main object is created)
	{
		/* autoExpenser::main::constructor
			
		*/
		
		### settings
		
		@%s{msgDebugDef}	= "This is a definitely a bug. You should report it to the software developer."
		@%s{msgDebugForgot}	= "If you see this, it means the developer forgot to comment this line."
		@%s{msgDebugProb}	= "This is probably a bug and should be reported to the software developer."
		@%s{osDirSlash}		= "\\"
		@%s{programName}	= "Auto Expenser"
		@%s{programNameDev}	= "autoExpenser"
		@%s{programVersion}	= "v 0.1"
		@%s{settingsFile}	= $file.fixpath($file.homedir()".autoExpenser/settings.conf")
		@%s{settingsPath}	= $file.fixpath($file.homedir()".autoExpenser")
		  @%s{dataSetsPath}	= $file.fixpath(@%s{settingsPath}"/dataSets")
		
		### variable aliases - these are aliases of some variable names above to make it easier for development
		
		@%a{pnd} 			= @%s{programNameDev}
		@%a{msgDebugDef}	= @%s{msgDebugDef}
		@%a{msgDebugForgot}	= @%s{msgDebugForgot}
		@%a{msgDebugProb}	= @%s{msgDebugProb}
		
		### class variables
		
		@%arrBDTKeepColumns			= $array()
		@%arrBDTKeepColumnsNewNames	= $array()
		@%arrCSVDataSetNames			= $array()
		@%debug 					= $true
		@%fioConfigs				= $new(autoexpenser::configio, $$, "@%a{pnd}|main|fioConfigs")
		// @%dtblNewData			= declared in main::slotButtonClicked::case ("KeepColumnsContinue")
		@%intPrevTab				= 0
		@%intBankDataKeepCount		= 0
		
		### start up checks
		
		if ($file.exists(@%s{settingsFile}) == $false)
		{
			debug -c settingsFile does not exist
			if ($file.exists($str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})) == $false)
			{
				debug -c program user directory does not exist, attempting to create it
				debug -c we are making: $str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})
				file.mkdir $str.lefttolast(@%s{settingsFile}, @%s{osDirSlash})
			}
		}
		
		### widgets
		
		@$setWindowTitle(@%s{programName} @%s{programVersion})
		@$setGeometry(0,0,560,300)
		@$centerToScreen()
		
		@%l0 = $new(layout, $$, "@%a{pnd} | main | layout 0")
		@%l0->$setSpacing(20)
		
		// create tabWidget
		@%tabwTabs = $new(tabWidget, $$, "@%a{pnd}|main|tabwidget")
		
		// add the tabwidget to the layout of the main window widget
		@%l0->$addMultiCellWidget(@%tabwTabs, 1,1,0,0)
		
		// create tab 'pages'
		@%wgtPageSettings	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|Settings")
		@%wgtPageCSVSet		= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|CSVSet")
		@%wgtPageBankData	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|BankData")
		@%wgtPageDataTrans	= $new(widget, $$, "@%a{pnd}|main|tabwidget|Page|DataTrans")
		
		// create 'page' layout
		@%lPageSettings = $new(layout, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Layout")
		@%lPageCSVSet = $new(layout, @%wgtPageCSVSet, "@%a{pnd}|main|tabwidget|Page|CSVSet|Layout")
		@%lPageBankData = $new(layout, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Layout")
		@%lPageDataTrans = $new(layout, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|Layout")
		
		// create 'page' child widgets
		
		### Settings tab
			// Local
		@%lblSettingsTitleLocal = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|TitleLocal")
		@%lblSettingsTitleLocal->$setText("<b>Local</b>")
		
		@%lblLocalDatabase = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|localDatabase")
		@%lblLocalDatabase->$setText("Database Location: ")
		
		@%leLocalDatabase = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|localDatabase")
		@%leLocalDatabase->$setMinimumWidth(50)
		
		@%btnLocalDatabase = $new(button, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Button|localDatabase")
		@%btnLocalDatabase->$setText("Browse")
		
			// Remote
		@%lblSettingsTitleRemote = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|TitleRemote")
		@%lblSettingsTitleRemote->$setText("<b>Remote</b>")
		
		@%lblRemoteDBHost = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBHost")
		@%lblRemoteDBHost->$setText("Database Host: ")
		@%leRemoteDBHost = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBHost")
		@%leRemoteDBHost->$setMinimumWidth(50)
		
		@%lblRemoteDBUser = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBUser")
		@%lblRemoteDBUser->$setText("Database User: ")
		@%leRemoteDBUser = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBUser")
		@%leRemoteDBUser->$setMinimumWidth(50)
		
		@%lblRemoteDBPass = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBPass")
		@%lblRemoteDBPass->$setText("Database Password: ")
		@%leRemoteDBPass = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBPass")
		@%leRemoteDBPass->$setMinimumWidth(50)
		@%leRemoteDBPass->$setEchoMode(Password)
		
		@%lblRemoteDBName = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBName")
		@%lblRemoteDBName->$setText("Database Name: ")
		@%leRemoteDBName = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBName")
		@%leRemoteDBName->$setMinimumWidth(50)
		
		@%lblRemoteDBTable = $new(label, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Label|remoteDBTable")
		@%lblRemoteDBTable->$setText("Table Name: ")
		@%leRemoteDBTable = $new(lineedit, @%wgtPageSettings, "@%a{pnd}|main|tabwidget|Page|Settings|Line Edit|remoteDBTable")
		@%leRemoteDBTable->$setMinimumWidth(50)
		
			// page layout settings
		
		@%lPageSettings->$addMultiCellWidget(@%lblSettingsTitleLocal,		0,0,0,2)
		@%lPageSettings->$addMultiCellWidget(@%lblLocalDatabase,			1,1,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leLocalDatabase,			1,1,1,1)
		@%lPageSettings->$addMultiCellWidget(@%btnLocalDatabase,			1,1,2,2)
		@%lPageSettings->$addMultiCellWidget(@%lblSettingsTitleRemote,		2,2,0,2)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBHost,			3,3,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBHost,			3,3,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBUser,			4,4,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBUser,			4,4,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBPass,			5,5,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBPass,			5,5,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBName,			6,6,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBName,			6,6,1,1)
		@%lPageSettings->$addMultiCellWidget(@%lblRemoteDBTable,			7,7,0,0)
		@%lPageSettings->$addMultiCellWidget(@%leRemoteDBTable,			7,7,1,1)
		
		@%lPageSettings->$setRowStretch(0, 0)
		@%lPageSettings->$setRowStretch(1, 1)
		@%lPageSettings->$setColumnStretch(0, 1)
		@%lPageSettings->$setColumnStretch(1, 2)
		@%lPageSettings->$setColumnStretch(2, 0)
		
		@%lPageSettings->$setAlignment(@%lblSettingsTitleLocal,	Bottom)
		@%lPageSettings->$setAlignment(@%lblSettingsTitleRemote,	Bottom)
		
		### CSVSets  tab
		
		@%btnCSVSetAdd = $new(button, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Button|DataSetAdd")
		@%btnCSVSetAdd->$setText("➕")
		@%btnCSVSetAdd->$setTooltip("Add a New CSV Set")
		@%btnCSVSetAdd->$setMaximumWidth(30)
		
		@%lblCSVSetDataSet = $new(label, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|Label|DataSet")
		@%lblCSVSetDataSet->$setText("CSV Set: ")
		
		@%coboCSVSetDataSet = $new(combobox, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSet|ComboBox|DataSet")
		
		@%dtblCSVSetCategories = $new(autoexpenser::datatable, @%wgtPageCSVSets, "@%a{pnd}|main|tabwidget|Page|CSVSets|DataTable|Categories")
		
		@%lPageCSVSet->$addMultiCellWidget(@%btnCSVSetAdd,			0,0,0,0)
		@%lPageCSVSet->$addMultiCellWidget(@%lblCSVSetDataSet,		0,0,1,1)
		@%lPageCSVSet->$addMultiCellWidget(@%coboCSVSetDataSet,		0,0,2,2)
		@%lPageCSVSet->$addMultiCellWidget(@%dtblCSVSetCategories,		1,1,0,2)
		
		@%lPageCSVSet->$setColumnStretch(0, 0)
		@%lPageCSVSet->$setColumnStretch(1, 0)
		@%lPageCSVSet->$setColumnStretch(2, 1)
		
		### Bank data tab
		
		@%lblBankDataFile = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|BankDataFile")
		@%lblBankDataFile->$setText("Bank Data File: ")
		
		@%leBankDataFile = $new(lineedit, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Line Edit|BankDataFile")
		@%leBankDataFile->$setMinimumWidth(50)
		
		@%btnBankDataFile = $new(button, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Button|BankDataFile")
		@%btnBankDataFile->$setText("Browse")
		
		@%lblBankDataSepType = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|BankDataSepType")
		@%lblBankDataSepType->$setText("Seperator: ")
		@%coboBankDataSepType = $new(combobox, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|ComboBox|BankDataSepType")
		@%coboBankDataSepType->$insertItem("Comma")
		@%coboBankDataSepType->$insertItem("Pipe")
		@%coboBankDataSepType->$insertItem("Tab")
		
		@%cbBankDataFirstLine = $new(checkbox, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|CheckBox|BankDataFirstline")
		@%cbBankDataFirstLine->$setText("First line has column titles")
		
		@%btnBankDataLoad = $new(button, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Button|BankDataLoad")
		@%btnBankDataLoad->$setText("Load Data")
		
		@%dtblBankDataTable = $new(autoexpenser::datatable, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|datatable|BankDataTable")
		
		@%lblBankDataStatus = $new(label, @%wgtPageBankData, "@%a{pnd}|main|tabwidget|Page|BankData|Label|Status")
		@%lblBankDataStatus->$setFrameStyle("Sunken")
		@%lblBankDataStatus->$setText("")
		@%lblBankDataStatus->$setMouseTracking($true)
		
			// page layout settings
		
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataFile,		0,0,0,0)
		@%lPageBankData->$addMultiCellWidget(@%leBankDataFile,		0,0,1,1)
		@%lPageBankData->$addMultiCellWidget(@%btnBankDataFile,		0,0,2,2)
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataSepType,		1,1,0,0)
		@%lPageBankData->$addMultiCellWidget(@%coboBankDataSepType,	1,1,1,2)
		@%lPageBankData->$addMultiCellWidget(@%cbBankDataFirstLine,	2,2,0,2)
		@%lPageBankData->$addMultiCellWidget(@%btnBankDataLoad,		3,3,0,2)
		@%lPageBankData->$addMultiCellWidget(@%dtblBankDataTable,		4,6,0,2)
		@%lPageBankData->$addMultiCellWidget(@%lblBankDataStatus,		7,7,0,2)
		
		@%lPageBankData->$setRowStretch(7, 0)
		@%lPageBankData->$setRowStretch(5, 1)
		
		### Data Translation tab
		
		@%lblDataTransHelp = $new(label, @%wgtPageDataTrans, "@%a{pnd}|main|tabwidget|Page|DataTrans|Label|Help")
		@%lblDataTransHelp->$setText("If you see this message go back to the Bank Data tab and do the following: <br/><ol><li>Select a CSV data file</li><li>Select Seperator type and Title row options</li><li>Click Load Data button</li><li>Select which columns to preserve and set title names</li><li>Click Continue button</li></ol>")
		
		
			// page layout settings
		
		@%lPageDataTrans->$addMultiCellWidget(@%lblDataTransHelp,		0,0,0,0)
		
		// add 'pages' to tabwidget
		@%tabwTabs->$addTab(@%wgtPageSettings,	"Settings")
		@%tabwTabs->$addTab(@%wgtPageCSVSet,		"CSV Sets")
		@%tabwTabs->$addTab(@%wgtPageBankData,	"Bank Data")
		@%tabwTabs->$addTab(@%wgtPageDataTrans,	"Data Translation")
		
		### objects connect
		
		@$addPrivateImpls()
		
		objects.connect @%btnBankDataFile clicked			$$ browseButtonClicked
		objects.connect @%btnBankDataFile signalDialogFile	$$ slotDialogFile
		
		objects.connect @%btnBankDataLoad clicked			$$ slotButtonClicked
		
		objects.connect @%btnCSVSetAdd clicked			$$ slotButtonClicked
		
		objects.connect @%btnLocalDatabase clicked			$$ browseButtonClicked
		objects.connect @%btnLocalDatabase signalDialogFile	$$ slotDialogFile
		
		objects.connect @%coboCSVSetDataSet activated		$$ slotUpdateWidgets
		
		objects.connect @%leLocalDatabase textChanged		$$ settingsCatchChanges
		objects.connect @%tabwTabs currentChanged			$$ settingsSaveToDisk
		objects.connect @%tabwTabs currentChanged			$$ slotUpdateWidgets
		
		### main run
		@$show()
	}
	
	function browseButtonClicked(handles a browse button that is used to look for a file)
	{
		/* autoexpenser::main::browseButtonClicked
		
			This function is a slot to handle when a "Browse" button is clicked when the user wants to search for a file.
		*/
		
		#if (@%debug) {debug -c \n0 = $0\n1 = $1\nsignalSender = @$signalSender\nsignalSender->name = @$signalSender()->$name()\nsignalName = @$signalName()\nthis->className = @$className;}
		
		dialog.file -b ("Open", "Open File...",,, @$signalSender, @%s{msgDebugForgot}, @%s{msgDebugDef})
		{
			// dev-note:	$0 contains the absolute path to the chosen file. if the user cancels, $0 will be null
			//			$1 will contain the signalSender name, so we can determine what we should do with $0 if it exists
			//			$2 contains a debug message string
			//			$3 contains a debug message string
			if ($0)
			{
				if ($1)
				{
					%signalSender = $1
					%signalSender->$emit("signalDialogFile", $0)
				}
				else
				{
					debug -c "Argument 1 (signalSender) was null. This is a problem because we don't know which widget asked for the file. $3"
				}
			}
			else
			{
				debug -c "Argument 0 (filename) was null. User must have cancelled the selection. $2"
			}
		
		}
	}
	
	function bankDataReadFile(this function parses a file into the bankdatatable object)
	{
		/* autoexpenser::main::bankDataReadFile
		
			This function parses a file into the bankdatatable object: @%bdtBankDataTable
			If the function successfully imports data from the file, it will build a set of child widgets
			for the user to select which data to bring over to the Data Translation tab.
		
			The child widgets will be accessed in the autoexpenser::main::slotButtonClicked function, 
			case ("KeepColumnsContinue")
		
			Parameters - bankDataReadFile(<filename>,<seperator>,[firstRow],[target])
		
				$0: filename:string		The filename to read from
				$1: seperator:string		The seperator character to use on the file data
				$2: firstRow:bool		Whether the first line in the file has column titles or not
				$3: target:datatable		The datatable object to put the parsed data into
		*/
		
		%fileIn = $0
		%firstRow = $2
		%sep = $1
		%success = $false
		%target = $3
		
		if (%fileIn && %sep)
		{
			if ($file.exists(%fileIn))
			{
				%emptyLines = 0
				%fileH = $new(file,,"slotButtonClicked|File Handling Object")
				%fileH->$setName(%fileIn)
				%fileH->$open("ReadOnly")
				%i = 0
				%line = $true
				%rowsAdded = 0
				%target->%columnTitles = $array()
		
				while (%line)
				{
					%line = %fileH->$readLine()
					
					%row = $str.split(%sep,%line)
					if (%i == 0)
					{
						%countCol = %row[]#;
						%target->$setColumnCount(%countCol)
						# set placeholder column titles
						for (%j = 0; %j < %countCol; %j++)
						{
							%target->%columnTitles <+ $str.upcase($char($(%j + 97)))
						}
		
						if (%firstRow)
						{
							// use this row to set the column titles
							// check if row field value has quotes on both ends, remove if it does.
							for (%j = 0; %j < %row[]#; %j++)
							{
								if ($str.match(\"*\",%row[%j]))
								{
									%row[%j] = $str.rightfromfirst($str.chop($str.strip(%row[%j]), 1),\")
								}
							}
							%target->%columnTitles = %row
						}
						%target->$setColumnTitles()
					}
		
					// process line as a normal row
					// check if this row has enough columns
					if (%row[]# >= %countCol)
					{
						// sort this row into 'acceptable' row data: add directly to bankdatatable object
						%target->$addRow(%row)
						%rowsAdded++
					}
					else
					{
						// sort this row into 'problematic' row data
						// check if the line is not empty
						if (%line != "")
						{
							// add this line's content to the problematic data tablewidget
						}
						else
						{
							// this line is empty, dont worry about it
							%emptyLines++
						}
					}
					%i++
					@%lblBankDataStatus->$setText("%i total lines read from file. %rowsAdded rows added to data table. %emptyLines empty lines in file.")
					@%lblBankDataStatus->$setFrameStyle("Box", "Raised")
				}
				%success = $true
			}
			else
			{
				dialog.message -b ("Notice", "Bank data file not found.<br/><br/>There was no file found at:<br/><br/>%fileIn<br/><br/>Check the filename and path and try again.", $icon(info), "/okay...")
				{}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%s{msgDebugProb}";}
		}
		
		// create options at bottom of the Bank Data page for Data Translation
		if (%success)
		{
			# if the widgets for the column preservation already exist, we should delete/reset them first.
			if ($isSet(@%vboxKeepColumns)) {delete @%vboxKeepColumns;}
			if ($isSet(@%arrBDTKeepColumns)) {@%arrBDTKeepColumns = $array();}
			if ($isSet(@%arrBDTKeepColumnsNewNames)) {@%arrBDTKeepColumnsNewNames = $array();}
		
			debug -c isSet vbox: $isSet(@%vboxKeepColumns)
		
			@%vboxKeepColumns 		= $new(vbox, @%wgtPageBankData)
		
			@%lblBankDataKeepColumns	= $new(label, @%vboxKeepColumns)
			@%lblBankDataKeepColumns->$setText("<b>Column Preservation</b>")
			@%lblBankDataKeepColumns->$setToolTip("Select which columns to preserve and what to call them")
		
			@%hboxKeepColumns 		= $new(hbox, @%vboxKeepColumns)
			@%hboxKeepColumnsNewNames	= $new(hbox, @%vboxKeepColumns)
			@%btnBankDataContinue		= $new(button, @%vboxKeepColumns, "@%a{pnd}|main|tabwidget|Page|BankData|bankdatatable|Button|KeepColumnsContinue")
			@%btnBankDataContinue->$setText("Continue")
			@%btnBankDataContinue->$setEnabled($false)
			objects.connect @%btnBankDataContinue clicked $$ slotButtonClicked
		
			debug -c columnTitles: @%dtblBankDataTable->%columnTitles
		
			for (%i = 0; %i < @%dtblBankDataTable->%columnTitles[]#; %i++)
			{
				%colTitle = @%dtblBankDataTable->%columnTitles[%i]
				// for each columnTitle, we need to make a checkbox
				@%arrBDTKeepColumns[%i] = $new(checkbox, @%hboxKeepColumns, "@%a{pnd}|main|tabwidget|Page|BankData|bankdatatable|ArrayKeepColumns|%i")
				@%arrBDTKeepColumns[%i]->$setText(%colTitle)
				@%arrBDTKeepColumns[%i]->$setToolTip("Tick to preserve %colTitle column for Data Translation")
		
				@%arrBDTKeepColumnsNewNames[%i] = $new(lineedit, @%hboxKeepColumnsNewNames)
				@%arrBDTKeepColumnsNewNames[%i]->$setText("%colTitle")
				@%arrBDTKeepColumnsNewNames[%i]->$setToolTip("Enter the name that you want the %colTitle column to be after Data Translation")
		
				objects.connect @%arrBDTKeepColumns[%i] toggled $$ slotCheckBoxKeepColumnsToggled
			}
		
			@%lPageBankData->$addMultiCellWidget(@%vboxKeepColumns, 9,9,0,2)
		}
		
		return %success
	}
	
	function addPrivateImpls(adds privateimpls)
	{
		/* autoExpenser::main::addPrivateImpls
		
			This function is to be used when you are f()rced to use a privateimpl instead of objects.connect to 
			create a handler for an object.
		*/
	}
	
}

class("autoexpenser::datatable","tablewidget")
{
	function setColumnTitles(sets the column titles using the classes internal column title array)
	{
		/* autoexpenser::datatable::setColumnTitles
		
			set the column titles for the tablewidget based on the @%columnTitles array
			dev-note: note that @%columnTitles is part of the datatable class, not the main class.
		
		*/
		
		@$setColumnCount(@%columnTitles[]#)
		@$setHorizontalHeaderLabels(@%columnTitles)
		return $true
	}
	
	function getColumnTitles(return the column titles as a list object)
	{
		// autoexpenser::datatable::getColumnTitles
		// return the column titles as a list object
		
		%success = $false
		%colCount = @$columnCount()
		
		if (%colCount > 0)
		{
			for (%i = 0; %i < %colCount; %i++)
			{
				
			}
		}
		
		return %success
	}
	
	function constructor(runs when the datatable object is created)
	{
		/* autoexpenser::datatable::constructor
		
		*/
		
		### class members
		
		// inherit debug value from the parent if it exists, else set debug to false
		if (@$parent == $true) {@%debug = @$parent()->%debug;} else {@%debug = $false;}
		
		@%s{msgDebugDef}	= "This is a definitely a bug. You should report it to the software developer."
		@%s{msgDebugForgot}	= "If you see this, it means the developer forgot to comment this line."
		@%s{msgDebugProb}	= "This is probably a bug and should be reported to the software developer."
		
		@%columnKeepTitles = $hash()
		@%columnTitles = $array()
		@%intRowCurrent = 0
	}
	
	function clearTable(clears the current table back to zero contents)
	{
		/* autoexpenser::datatable::clearTable
		
			clears the current table back to zero contents
		*/
		
		@$clear()
		for ($false; @%intRowCurrent >= 0; @%intRowCurrent--)
		{
			@$removeRow(@%intRowCurrent)
		}
		@%intRowCurrent = 0
		return $true
	}
	
	function addRow(adds a row to the datatable object)
	{
		/* autoexpenser::datatable::addRow
		
			Adds a row to the datatable object
		
			Parameters - addRow(<rowData>,[cellFlag1, cellFlag2, ...])
		
				$0:  addRow:array		Array that holds the data to insert into the row
				$1-: cellFlag:string		String argument for flag to apply onto cells that are added (see tablewidget 
									docs for flags)
		
		*/
		
		%flag				= $1
		%rowData			= $0
		%strAcceptedFlags	= "selectable,editable,dragEnabled,dropEnabled,userCheckable,enabled,tristate"
		%success 			= $false
		
		if ($typeOf(%rowData) == "array")
		{
			if ($str.contains(%strAcceptedFlags,%flag) == $false) {%flag == "disabled";}
		debug -c flag = %flag
		
			@$setRowCount($(@$rowCount + 1))
			for (%i = 0; %i < %rowData[]#; %i++)
			{
				// check if row field value has quotes on both ends, remove if it does.
				if ($str.match(\"*\",%rowData[%i]))
				{
					%rowData[%i] = $str.rightfromfirst($str.chop($str.strip(%rowData[%i]), 1),\")
				}
				// note: %i is the column uid, @%intRowCurrent is the row uid
				@$setText(@%intRowCurrent,%i,%rowData[%i])
				@$setItemFlags(@%intRowCurrent, %i, %flag)
			}
			@%intRowCurrent++
			%success = $true
		}
		else
		{
			if (@%debug) {debug -c "Argument 0 (rowData) was not type 'array'. Check your data values. @%s{msgDebugForgot}";}
		}
		
		return %success
	}
	
}

class("autoexpenser::configio","object")
{
	function writeToConfig(writes values to KVIrc Config type file)
	{
		/* autoexpenser::fileio::writeToConfig
			
			this function writes values to a KVIrc config type file
		
			Parameters - writeToConfig(<targetFilename>,<values>,[configSection],[containerType],[sort])
		
				$0: targetFilename:string	The filename to write to
				$1: values:variant		The variable that will hold the values to write to file
				$2: configSection:string	The section in the config file to write to
				$3: containerType:string	The type of the values variant (optional)
				$4: sort:boolean		Switch to sort values before they are written to file
		
			If $2 configSection is specified, the function will write to that section of the config file.
			If $3 containerType is not specified, the function will attempt to detect what type of container the values are in
			and act accordingly.
			If $4 is $true the function will sort the values before they write to disk if possible.
		
			Return Value
				
				This function will return boolean $false if the values argument type passed to it is not recognized.
				If the values argument type is recognized, either string "zero" will be returned (if the values argument was empty)
				or the integer number of values written to the config will be returned.
		
		*/
		
		%configSection	= $2
		%containerType	= $3
		%sort 		= $4
		%success		= $false
		%targetFilename	= $0
		%values		= $1
		
		if (%targetFilename == $true && %values == $true) 
		{
			if (%containerType == $false)
			{
				//if (@%debug) {debug -c "containerType was not found. @%a{msgDebugForgot}";}
				# no container type passed to us, so we have to try to detect what type of conatiner our values are in
				%containerType = $typeof(%values)
				if (%containerType == "hobject")
				{
					%containerType = %values->$className()
				}
			}
			
			%cfgID = $config.open(%targetFilename,"rw")
			if (%cfgID == $true)
			{
				if (%configSection == $true) {config.setsection %cfgID %configSection;}
				// dev-note: we can now do a switch/case on %containerType to process the values to save to config
				// if the containerType is unknown in our switch/case block, we wont save anything to file and output debug error instead
				switch (%containerType)
				{
					case ("array"):
					{
						%success = 0
						// loop array
						for (%i = 0; %i <= %values[]#; %i++)
						{
							config.write %cfgID %i %values[%i]
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					case ("hash"):
					{
						%success = 0
						// loop hash
						foreach (%k, $keys(%values))
						{
							config.write %cfgID %k %values{%k}
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					case ("list"):
					{
						%success = 0
						// iterate list
						%values->$moveFirst()
						while (%values->$moveNext())
						{
							config.write %cfgID %success %values->$current()
							%success++
						}
						if (%success == "0") {%success = "zero";}
						break;
					}
					default:
					{
						// handle unknown containerType
						if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type. Check the variables passed to this function. @%a{msgDebugProb}";}
						break;
					}
				} // end switch
				config.close %cfgID
			}
			else
			{
				if (@%debug) {debug -c "Argument 0: '%targetFilename' failed to open. Check file permissions?. @%a{msgDebugProb}";}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%a{msgDebugDef}";}
		}
		
		return %success
	}
	
	function readFromConfig(reads values from KVIrc Config type file)
	{
		/* autoexpenser::fileio::readFromConfig
			
			this function reads values from a KVIrc config type file
		
			Parameters - readFromConfig(<sourceFilename>,<containerType>,[configSection],[sort])
		
				$0: sourceFilename:string	The filename to read from
				$1: containerType:string	The type of the values variant (optional)
				$2: configSection:string	The section in the config file to read from. If this is not set, the entire config will 
									be read.
				$3: sort:boolean		Switch to sort values after they are read from file
		
			If $1 configSection is specified, the function will read from that section of the config file, else it will read the entire
			config.
			$2 containerType is not specified, the function will attempt to detect what type of container the values will be in
			and act accordingly
			If $3 is $true the function will sort the values after they are read from disk if possible.
		
			Return Value
				
				This function will return an object of %containerType with values from %sourceFilename. 
				If %configSection is specified, it will only return values from that section in the %sourceFilename.
				If %sort is $true, it will sort the values in the returned object if possible.
				Otherwise it will return $false.
				Note: to find out how many items were pulled from the config file, you should count the returned object entries 
				in the calling code.
		
		*/
		
		%configSection	= $2
		%containerType	= $1
		%sort 		= $3
		%success		= $null
		%sourceFilename	= $0
		
		if (%sourceFilename == $true && %containerType == $true) 
		{
			// ensure config file exists
			if ($file.exists(%sourceFilename))
			{
				if (%containerType == "list") {%success = $new(list);	}
		
				%cfgID = $config.open(%sourceFilename,"r")
				if (%cfgID == $true)
				{
					%sections = $config.sectionlist(%cfgID)
					// loop through entire config, section-by-section. check if user wants a specific section else get all the values
					foreach --all (%currentSection, %sections)
					{
						if ((%configSection == $false) || (%configSection == $true && %currentSection == %configSection))
						{
							config.setsection %cfgID %currentSection
							%sectionKeys = $config.keylist(%cfgID)
							if (%sectionKeys == $true)
							{
								foreach (%k, %sectionKeys)
								{
									%v = $config.read(%cfgID, %k)
									// dev-note: we can now do a switch/case on %containerType to process the values to read from config
									// if the containerType is unknown in our switch/case block, we wont read anything from file and output debug error instead
									switch (%containerType)
									{
										case ("array"):
										{
											%success[%k] = %v
											break;
										}
										case ("hash"):
										{	
											%success{%k} = %v
											break;
										}
										case ("list"):
										{
											%success->$append(%v)
											break;
										}
										default:
										{
											// handle unknown containerType
											if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type. Check the variables passed to this function. @%a{msgDebugProb}";}
											break;
										}
									} // end switch
								} // end foreach
							}
							else
							{
								// no keys were found in this section, so no point entering the inner loops
								if (@%debug) {debug -c No keys were found in section: %currentSection;}
							}
						}
						else
						{
							// if we get here it means that we want a specific section from the config file, but we are 
							// processing a section that we don't want. nothing really needs to happen here.
						}
					}
					config.close %cfgID
					if (%sort == $true)
					{
						switch(%containerType)
						{
							case ("array"):
							{
								%success = $sort(%success)
								break;
							}
							case ("list"):
							{
								%success->$sort()
							}
							default:
							{
								// handle unknown containerType for sorting
								// note: hashes are not sortable afaik
								if (@%debug) {debug -c "Argument 2 (containerType = %containerType) didn't exist or is an unknown type for sorting purposes. Check the variables passed to this function. @%a{msgDebugProb}";}
								break;
							}
						} // end switch
					} //end if sort == true
				}
				else
				{
					if (@%debug) {debug -c "Argument 0 sourceFilename: $b()%sourceFilename$b() could not be opened. Check folder permissions? @%a{msgDebugProb}";}
				}
			}
			else
			{
				if (@%debug) {debug -c "Argument 0 sourceFilename: $b()%sourceFilename$b() does not exist. Check folder permissions? @%a{msgDebugProb}";}
			}
		}
		else
		{
			if (@%debug) {debug -c "Required arguments 0 or 1 did not exist. Check the values passed to this function. @%a{msgDebugDef}";}
		}
		
		return %success
	}
	
	function constructor(the constructor of the configio class)
	{
		/* autoexpenser::fileio::constructor
		
			Notes: 
			  @%a		is an 'alias' variable, which gives access to values from the parent object.
			  @%debug 	is a boolean that enables debugging messages.
		
		*/
		
		### class members
		
		// inherit values from the parent if it exists, else use default values
		if (@$parent == $true) 
		{
			@%debug	= @$parent()->%debug;
			@%a		= @$parent()->%a;
		}
		else 
		{
			@%debug	= $false;
			@%a		= $false;
		}
	}
	
}

